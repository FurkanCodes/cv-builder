// useReactToPdf.ts
"use client";

import { useRef } from "react";
import { jsPDF } from "jspdf";
import html2canvas from "html2canvas-pro";

type PdfOptions = {
  filename?: string;
  options?: {
    format?: "a4" | "letter";
    orientation?: "portrait" | "landscape";
    unit?: "mm" | "cm" | "in" | "px" | "pt";
    margin?: {
      top?: string | number;
      right?: string | number;
      bottom?: string | number;
      left?: string | number;
    };
    quality?: number; // Note: jsPDF addImage 'quality' is for JPEGs, not directly used here for PNG
    scale?: number;
  };
};

export const useReactToPdf = (pdfOptions: PdfOptions = {}) => {
  const targetRef = useRef<HTMLDivElement>(null);

  const defaultOptions = {
    filename: "download.pdf",
    options: {
      format: "a4" as "a4" | "letter",
      orientation: "portrait" as "portrait" | "landscape",
      unit: "mm" as "mm" | "cm" | "in" | "px" | "pt",
      margin: {
        top: "10",
        right: "10",
        bottom: "10",
        left: "10",
      },
      quality: 2, // This seems to be for html2canvas scale, not PDF quality directly for PNGs
      scale: 2, // html2canvas scale factor
    },
  };

  // Deep merge options
  const mergedOptions = {
    ...defaultOptions,
    ...pdfOptions,
    options: {
      ...defaultOptions.options,
      ...(pdfOptions.options || {}),
      margin: {
        ...defaultOptions.options.margin,
        ...(pdfOptions.options?.margin || {}),
      },
    },
  };

  const toPdf = async () => {
    if (!targetRef.current) {
      console.error("Target ref is not defined for PDF export.");
      throw new Error("Target ref is not defined");
    }

    // Wait for images within the targetRef to load
    try {
      const images = Array.from(targetRef.current.getElementsByTagName("img"));
      const imageLoadPromises = images.map((img) => {
        // Check if image is already loaded and valid
        if (img.complete && img.naturalHeight !== 0) return Promise.resolve();
        return new Promise<void>((resolve) => {
          // Removed reject for simplicity, always resolve
          img.onload = () => resolve();
          img.onerror = () => {
            console.warn(
              "An image failed to load for PDF export (src):",
              img.src
            );
            resolve(); // Resolve even on error to not block PDF generation
          };
        });
      });

      // Timeout for image loading to prevent indefinite wait
      const imageWaitTimeout = 7000; // 7 seconds
      await Promise.all(
        imageLoadPromises.map((p) =>
          Promise.race([
            p,
            new Promise<void>((resolve) =>
              setTimeout(() => {
                console.warn("An image load promise timed out.");
                resolve(); // Resolve on timeout
              }, imageWaitTimeout)
            ),
          ])
        )
      );
      console.log("Image loading phase complete/timed-out for PDF export.");
    } catch (error) {
      console.warn(
        "Error during image loading phase, attempting PDF generation anyway:",
        error
      );
    }

    // A small delay can sometimes help ensure all rendering updates are flushed
    // await new Promise(resolve => setTimeout(resolve, 300));

    try {
      const { filename } = mergedOptions;
      const opt = mergedOptions.options;

      console.log(
        "Preparing to generate PDF with html2canvas. Target element:",
        targetRef.current
      );
      const canvas = await html2canvas(targetRef.current, {
        scale: opt.scale,
        useCORS: true,
        logging: true, // Enable html2canvas logging for detailed diagnostics
        // backgroundColor: '#ffffff', // Set if transparent background becomes black. Better to set on targetRef div.
        width: targetRef.current.offsetWidth, // Use actual rendered width in pixels
        height: targetRef.current.offsetHeight, // Use actual rendered height in pixels
        scrollX: 0, // Assuming the targetRef itself is not scrollable, page scroll is handled by fixed pos.
        scrollY: 0,
        windowWidth: document.documentElement.scrollWidth, // Provide broader context
        windowHeight: document.documentElement.scrollHeight,
      });

      console.log(
        "Canvas generated by html2canvas. Attempting to get Data URL."
      );
      const imgData = canvas.toDataURL("image/png");

      if (
        !imgData ||
        !imgData.startsWith("data:image/png;base64,") ||
        imgData.length < 200
      ) {
        // Basic check
        console.error(
          "Generated PNG data URL seems invalid or too short. Length:",
          imgData?.length,
          "Start:",
          imgData?.substring(0, 100)
        );
        throw new Error(
          "Generated PNG data URL by html2canvas is invalid or empty."
        );
      }
      console.log("PNG data URL generated (length):", imgData.length);

      const pdf = new jsPDF({
        orientation: opt.orientation,
        unit: opt.unit,
        format: opt.format,
      });

      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();

      // Convert margin strings to numbers. Assumes margins are in the same unit as pdf.unit if strings.
      // TODO: Implement robust unit conversion if margin units (e.g. 'cm') can differ from pdf.unit ('mm')
      const margin = {
        top: parseFloat(String(opt.margin.top)),
        right: parseFloat(String(opt.margin.right)),
        bottom: parseFloat(String(opt.margin.bottom)),
        left: parseFloat(String(opt.margin.left)),
      };

      const contentWidth = pdfWidth - margin.left - margin.right;
      const canvasAspectRatio = canvas.width / canvas.height;
      let contentHeight = contentWidth / canvasAspectRatio;

      const availableHeight = pdfHeight - margin.top - margin.bottom;
      if (contentHeight > availableHeight) {
        console.warn(
          `Content (${contentHeight}${opt.unit}) is taller than available page height (${availableHeight}${opt.unit}). It will be scaled down to fit.`
        );
        contentHeight = availableHeight;
        // contentWidth = contentHeight * canvasAspectRatio; // Optionally adjust width too, though usually width is the constraint
      }

      pdf.addImage(
        imgData,
        "PNG",
        margin.left,
        margin.top,
        contentWidth,
        contentHeight,
        undefined, // alias
        "FAST" // compression (NONE, FAST, MEDIUM, SLOW). FAST is less intensive.
      );

      pdf.save(filename);
      console.log("PDF exported successfully:", filename);
      return true;
    } catch (error) {
      console.error("Error generating PDF in useReactToPdf hook:", error);
      if (
        error instanceof Error &&
        (error.message.toLowerCase().includes("png") ||
          error.message.toLowerCase().includes("canvas"))
      ) {
        console.error(
          "This error often relates to html2canvas rendering issues. Check its logs (enabled above). Common causes: unsupported CSS, issues with external resources (like images not loading due to CORS or network errors), or the element being hidden/styled in a way html2canvas cannot process."
        );
      }
      throw error;
    }
  };

  return { targetRef, toPdf };
};
